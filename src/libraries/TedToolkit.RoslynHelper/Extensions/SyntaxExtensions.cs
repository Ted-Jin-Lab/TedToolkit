using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TedToolkit.RoslynHelper.Names;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace TedToolkit.RoslynHelper.Extensions;

/// <summary>
///     The extensions for the <see cref="Microsoft.CodeAnalysis.CSharp.SyntaxFactory" />
/// </summary>
public static class SyntaxExtensions
{
    /// <summary>
    ///     Add the comment
    /// </summary>
    /// <typeparam name="TNode"></typeparam>
    /// <param name="node"></param>
    /// <param name="comment"></param>
    /// <returns></returns>
    public static TNode WithXmlComment<TNode>(this TNode node, string comment = "/// <summary/>")
        where TNode : SyntaxNode
    {
        return node.WithLeadingTrivia(TriviaList([Comment(comment)]));
    }

    /// <summary>
    ///     Add the comment with inheritdoc.
    /// </summary>
    /// <param name="node"></param>
    /// <param name="name"></param>
    /// <typeparam name="TNode"></typeparam>
    /// <returns></returns>
    public static TNode WithXmlCommentInheritDoc<TNode>(this TNode node, IName? name = null)
        where TNode : SyntaxNode
    {
        return node.WithXmlCommentInheritDoc(name?.SummaryName);
    }

    /// <summary>
    ///     Add the comment with inheritdoc.
    /// </summary>
    /// <param name="node"></param>
    /// <param name="name"></param>
    /// <typeparam name="TNode"></typeparam>
    /// <returns></returns>
    public static TNode WithXmlCommentInheritDoc<TNode>(this TNode node, string? name = null)
        where TNode : SyntaxNode
    {
        return node.WithXmlComment(name is null
            ? "/// <inheritdoc/>"
            : $"/// <inheritdoc cref=\"{name}\"/>");
    }

    /// <summary>
    ///     The xml comment with method.
    /// </summary>
    /// <param name="node"></param>
    /// <param name="methodSymbol"></param>
    /// <typeparam name="TNode"></typeparam>
    /// <returns></returns>
    public static TNode WithXmlComment<TNode>(this TNode node, IMethodSymbol methodSymbol)
        where TNode : SyntaxNode
    {
        return node.WithXmlComment(
            $"/// <inheritdoc cref=\"{methodSymbol.OriginalDefinition.GetName().SummaryName}\"/>");
    }

    /// <summary>
    ///     Generate a node by the string.
    /// </summary>
    /// <typeparam name="TNode"></typeparam>
    /// <param name="code"></param>
    /// <returns></returns>
    public static TNode ParseSyntax<TNode>(string code) where TNode : MemberDeclarationSyntax
    {
        return (TNode)((CompilationUnitSyntax)ParseSyntaxTree(code).GetRoot()).Members[0];
    }

    /// <summary>
    ///     Generate the basic namespace declaration.
    /// </summary>
    /// <param name="name"></param>
    /// <param name="comment"></param>
    /// <returns></returns>
    public static BaseNamespaceDeclarationSyntax NamespaceDeclaration(string name, string? comment = null)
    {
        return MakeGenerated(FileScopedNamespaceDeclaration(ParseName(name)), comment);
    }

    /// <summary>
    ///     Make the node as the auto generated.
    /// </summary>
    /// <param name="syntax"></param>
    /// <param name="comment"></param>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T MakeGenerated<T>(T syntax, string? comment = null) where T : SyntaxNode
    {
        var text = "// <auto-generated/>";
        if (comment != null)
            text = "// <auto-generated>"
                   + "\n" + comment.Leading("// ")
                   + "\n// </auto-generated>";

        return syntax.WithLeadingTrivia(TriviaList(
            Comment(text),
            Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true)),
            Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true))));
    }

    #region Attribute

    /// <summary>
    /// </summary>
    /// <param name="generator"></param>
    /// <returns></returns>
    public static AttributeListSyntax GeneratedCodeAttribute(Type generator)
    {
        return AttributeList([
            Attribute(IdentifierName("global::System.CodeDom.Compiler.GeneratedCode"))
                .AddArgumentListArguments(
                    AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression,
                        Literal(generator.FullName ?? generator.Name))),
                    AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression,
                        Literal(generator.Assembly.GetName().Version?.ToString() ?? "1.0.0"))))
        ]);
    }

    /// <summary>
    ///     No user code attribute.
    /// </summary>
    /// <returns></returns>
    public static AttributeSyntax NonUserCodeAttribute()
    {
        return Attribute(IdentifierName("global::System.Diagnostics.DebuggerNonUserCode"));
    }

    /// <summary>
    ///     Overload resolution priority attribute.
    /// </summary>
    /// <returns></returns>
    public static AttributeSyntax OverloadResolutionPriorityAttribute(int priority)
    {
        return Attribute(IdentifierName("global::System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute"))
            .WithArgumentList(AttributeArgumentList(
            [
                AttributeArgument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(priority)))
            ]));
    }

    /// <summary>
    ///     Obsolete Attribute
    /// </summary>
    /// <param name="message">The message to show</param>
    /// <param name="error">make it as error</param>
    /// <returns></returns>
    public static AttributeSyntax ObsoleteAttribute(string message = "", bool error = false)
    {
        var attribute = Attribute(IdentifierName("global::System.Obsolete"));
        if (string.IsNullOrEmpty(message)) return attribute;
        return attribute.WithArgumentList(AttributeArgumentList(
        [
            AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(message))),
            AttributeArgument(
                LiteralExpression(error ? SyntaxKind.TrueLiteralExpression : SyntaxKind.FalseLiteralExpression))
        ]));
    }

    /// <summary>
    ///     Pure attribute.
    /// </summary>
    /// <returns></returns>
    public static AttributeSyntax PureAttribute()
    {
        return Attribute(IdentifierName("global::System.Diagnostics.Contracts.Pure"));
    }

    /// <summary>
    /// </summary>
    /// <param name="description"></param>
    /// <returns></returns>
    public static AttributeSyntax DescriptionAttribute(string description)
    {
        var attributeArgument =
            AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(description)));
        return Attribute(IdentifierName("global::System.ComponentModel.Description"),
            AttributeArgumentList(SingletonSeparatedList(attributeArgument)));
    }

    #endregion

    #region Enum Member

    /// <summary>
    /// </summary>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <returns></returns>
    public static EnumMemberDeclarationSyntax EnumMember(string name, byte value)
    {
        return EnumMemberDeclaration(name)
            .WithEqualsValue(EqualsValueClause(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(value))));
    }

    /// <summary>
    /// </summary>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <returns></returns>
    public static EnumMemberDeclarationSyntax EnumMember(string name, ushort value)
    {
        return EnumMemberDeclaration(name)
            .WithEqualsValue(EqualsValueClause(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(value))));
    }

    /// <summary>
    /// </summary>
    /// <param name="name"></param>
    /// <param name="value"></param>
    /// <returns></returns>
    public static EnumMemberDeclarationSyntax EnumMember(string name, uint value)
    {
        return EnumMemberDeclaration(name)
            .WithEqualsValue(EqualsValueClause(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(value))));
    }

    #endregion

    #region ITypeParameterName

    private static IEnumerable<ITypeParamName> RemoveDuplicated(this IEnumerable<ITypeParamName> names)
    {
        var nameSet = new HashSet<string>();
        return names.Where(p => nameSet.Add(p.SyntaxName));
    }

    /// <summary>
    ///     Add the parameter names for the class declaration
    /// </summary>
    /// <param name="classDeclaration"></param>
    /// <param name="typeParamNames"></param>
    /// <returns></returns>
    public static ClassDeclarationSyntax WithTypeParameterNames(this ClassDeclarationSyntax classDeclaration,
        params IEnumerable<ITypeParamName> typeParamNames)
    {
        var set = typeParamNames.RemoveDuplicated().ToArray();
        if (set.Length is 0) return classDeclaration;

        return classDeclaration
            .WithTypeParameterList(TypeParameterList(
            [
                .. set.Select(t => t.Syntax)
            ]))
            .WithConstraintClauses(
            [
                .. set.Select(t => t.ConstraintClause).OfType<TypeParameterConstraintClauseSyntax>()
            ]);
    }

    /// <summary>
    ///     Add the parameter names for the method declaration
    /// </summary>
    /// <param name="methodDeclaration"></param>
    /// <param name="typeParamNames"></param>
    /// <returns></returns>
    public static MethodDeclarationSyntax WithTypeParameterNames(this MethodDeclarationSyntax methodDeclaration,
        params IEnumerable<ITypeParamName> typeParamNames)
    {
        var set = typeParamNames.RemoveDuplicated().ToArray();
        if (set.Length is 0) return methodDeclaration;

        return methodDeclaration
            .WithTypeParameterList(TypeParameterList(
            [
                .. set.Select(t => t.Syntax)
            ]))
            .WithConstraintClauses(
            [
                .. set.Select(t => t.ConstraintClause).OfType<TypeParameterConstraintClauseSyntax>()
            ]);
    }

    /// <summary>
    ///     Add the parameter names for the interface declaration
    /// </summary>
    /// <param name="interfaceDeclaration"></param>
    /// <param name="typeParamNames"></param>
    /// <returns></returns>
    public static InterfaceDeclarationSyntax WithTypeParameterNames(
        this InterfaceDeclarationSyntax interfaceDeclaration,
        params IEnumerable<ITypeParamName> typeParamNames)
    {
        var set = typeParamNames.RemoveDuplicated().ToArray();
        if (set.Length is 0) return interfaceDeclaration;

        return interfaceDeclaration
            .WithTypeParameterList(TypeParameterList(
            [
                .. set.Select(t => t.Syntax)
            ]))
            .WithConstraintClauses(
            [
                .. set.Select(t => t.ConstraintClause).OfType<TypeParameterConstraintClauseSyntax>()
            ]);
    }

    /// <summary>
    ///     Add the parameter names for the struct declaration
    /// </summary>
    /// <param name="structDeclaration"></param>
    /// <param name="typeParamNames"></param>
    /// <returns></returns>
    public static StructDeclarationSyntax WithTypeParameterNames(
        this StructDeclarationSyntax structDeclaration,
        params IEnumerable<ITypeParamName> typeParamNames)
    {
        var set = typeParamNames.RemoveDuplicated().ToArray();
        if (set.Length is 0) return structDeclaration;

        return structDeclaration
            .WithTypeParameterList(TypeParameterList(
            [
                .. set.Select(t => t.Syntax)
            ]))
            .WithConstraintClauses(
            [
                .. set.Select(t => t.ConstraintClause).OfType<TypeParameterConstraintClauseSyntax>()
            ]);
    }

    /// <summary>
    ///     Add the parameter names for the name syntax
    /// </summary>
    /// <param name="typeSyntax"></param>
    /// <param name="typeParamNames"></param>
    /// <returns></returns>
    public static SimpleNameSyntax WithTypeParameterNames(this SimpleNameSyntax typeSyntax,
        params IEnumerable<ITypeParamName> typeParamNames)
    {
        string typeName;
        switch (typeSyntax)
        {
            case IdentifierNameSyntax id:
                typeName = id.Identifier.Text;
                break;

            case GenericNameSyntax generic:
                typeName = generic.Identifier.Text;
                break;

            default:
                return typeSyntax;
        }

        var set = typeParamNames.RemoveDuplicated().ToArray();
        if (set.Length is 0) return typeSyntax;

        return GenericName(typeName).WithTypeArgumentList(TypeArgumentList([
            ..set.Select(t => IdentifierName(t.SyntaxName))
        ]));
    }

    #endregion
}